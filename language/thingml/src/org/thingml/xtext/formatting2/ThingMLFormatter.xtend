/*
 * generated by Xtext 2.10.0
 */
package org.thingml.xtext.formatting2

import com.google.inject.Inject
import org.eclipse.xtext.formatting2.AbstractFormatter2
import org.eclipse.xtext.formatting2.FormatterRequest
import org.eclipse.xtext.formatting2.IFormattableDocument
import org.eclipse.xtext.util.ExceptionAcceptor
import org.thingml.xtext.constraints.ThingMLHelpers
import org.thingml.xtext.services.ThingMLGrammarAccess
import org.thingml.xtext.thingML.AbstractConnector
import org.thingml.xtext.thingML.Action
import org.thingml.xtext.thingML.ActionBlock
import org.thingml.xtext.thingML.ArrayIndex
import org.thingml.xtext.thingML.CompositeState
import org.thingml.xtext.thingML.ConditionalAction
import org.thingml.xtext.thingML.ConfigPropertyAssign
import org.thingml.xtext.thingML.Configuration
import org.thingml.xtext.thingML.Connector
import org.thingml.xtext.thingML.Enumeration
import org.thingml.xtext.thingML.EnumerationLiteral
import org.thingml.xtext.thingML.Event
import org.thingml.xtext.thingML.EventReference
import org.thingml.xtext.thingML.Expression
import org.thingml.xtext.thingML.ExpressionGroup
import org.thingml.xtext.thingML.ExternalConnector
import org.thingml.xtext.thingML.Function
import org.thingml.xtext.thingML.FunctionCallExpression
import org.thingml.xtext.thingML.FunctionCallStatement
import org.thingml.xtext.thingML.Handler
import org.thingml.xtext.thingML.Instance
import org.thingml.xtext.thingML.InternalPort
import org.thingml.xtext.thingML.InternalTransition
import org.thingml.xtext.thingML.LoopAction
import org.thingml.xtext.thingML.Message
import org.thingml.xtext.thingML.ObjectType
import org.thingml.xtext.thingML.Parameter
import org.thingml.xtext.thingML.PlatformAnnotation
import org.thingml.xtext.thingML.Port
import org.thingml.xtext.thingML.PrimitiveType
import org.thingml.xtext.thingML.Property
import org.thingml.xtext.thingML.PropertyAssign
import org.thingml.xtext.thingML.PropertyReference
import org.thingml.xtext.thingML.Protocol
import org.thingml.xtext.thingML.ProvidedPort
import org.thingml.xtext.thingML.Region
import org.thingml.xtext.thingML.RequiredPort
import org.thingml.xtext.thingML.SendAction
import org.thingml.xtext.thingML.Session
import org.thingml.xtext.thingML.State
import org.thingml.xtext.thingML.StateContainer
import org.thingml.xtext.thingML.Thing
import org.thingml.xtext.thingML.ThingMLModel
import org.thingml.xtext.thingML.Transition
import org.thingml.xtext.thingML.Type
import org.thingml.xtext.thingML.UnaryMinus
import org.thingml.xtext.thingML.Variable
import org.thingml.xtext.thingML.VariableAssignment
import org.thingml.xtext.thingML.Import

class ThingMLFormatter extends AbstractFormatter2 {
	
	@Inject extension ThingMLGrammarAccess
	
	// Fix to silence ConflictingRegionsException from the formatter
	override void initialize(FormatterRequest request) {
		super.initialize(request)
		// All exceptions will be ignored
		request.exceptionHandler = ExceptionAcceptor.IGNORING
	}

	def dispatch void format(ThingMLModel thingMLModel, extension IFormattableDocument document) {
		//println(textRegionAccess.toString())
		// TODO: format HiddenRegions around keywords, attributes, cross references, etc. 
		
		for (Type types : thingMLModel.getTypes()) {
			types.format;
		}
		for (Protocol protocols : thingMLModel.getProtocols()) {
			protocols.format;
		}
		for (Configuration configs : thingMLModel.getConfigs()) {
			configs.format;
		}
		
		//Formats all expressions in the model, so that we do not need to manually find expressions in if, guards, etc
		for(Expression e : ThingMLHelpers.getAllExpressions(thingMLModel)) {
			e.format
		}
	}	
	
	def dispatch void format(Configuration cfg, extension IFormattableDocument document) {
		cfg.interior[indent]
		cfg.regionFor.keyword("{").append[newLine]
		cfg.regionFor.keyword("}").surround[newLine]
		for(Instance i : cfg.instances) {
			i.append[newLine]
		}		
		for(AbstractConnector c : cfg.connectors) {
			c.format
		}		
		for(ConfigPropertyAssign cpa : cfg.propassigns) {
			cpa.format
		}
		//cfg.append[setNewLines(2,2,Integer.MAX_VALUE)]
	}
	
	def dispatch void format(Import i, extension IFormattableDocument document) {
		i.append[newLine]		
	}

	def dispatch void format(Connector c, extension IFormattableDocument document) {
		c.interior[indent]
		c.allRegionsFor.keyword(".").surround[noSpace]
		c.append[newLine]		
	}
	
	def dispatch void format(ExternalConnector c, extension IFormattableDocument document) {
		c.interior[indent]
		c.allRegionsFor.keyword(".").surround[noSpace]
		c.append[newLine]		
	}	

	def dispatch void format(Protocol p, extension IFormattableDocument document) {
		p.interior[indent]
		for (PlatformAnnotation annotations : p.getAnnotations()) {
			annotations.format;
			if (p.getAnnotations.size > 1) {
				annotations.prepend[newLine]
			}
		}
		p.append[setNewLines(1,2,Integer.MAX_VALUE)]
	}
	
	def dispatch void format(Enumeration e, extension IFormattableDocument document) {		
		formatType(e, document) 
		if (e.annotations.size > 0)
			e.regionFor.keyword("{").surround[newLine]
		else
			e.regionFor.keyword("{").append[newLine]
		e.regionFor.keyword("}").surround[newLine]
		for(EnumerationLiteral l : e.literals) {
			l.append[newLine]
		}
	}

	def dispatch void format(PrimitiveType primitiveType, extension IFormattableDocument document) {
		primitiveType.regionFor.keyword("<").surround[noSpace]
		primitiveType.regionFor.keyword(">").prepend[noSpace]		
		formatType(primitiveType, document) 
	}
	
	def dispatch void format(ObjectType objectType, extension IFormattableDocument document) {
		formatType(objectType, document)
	}
	
	def dispatch void format(Thing thing, extension IFormattableDocument document) {
		//TODO add a blank line in-between each bloack of features 
		thing.interior[indent]
		for(Property p : thing.properties) {
			p.format
		}				
		for(Port p : thing.ports) {
			p.format
		}
		for(Message m : thing.messages) {
			m.format
		}
		for (Function function : thing.functions) {
			function.format;
		}
		if (thing.behaviour !== null)
			thing.behaviour.format
		thing.regionFor.keyword("{").append[newLine].append[newLine]
		thing.regionFor.keyword("}").surround[newLine].append[newLine]
		//thing.append[setNewLines(2,2,Integer.MAX_VALUE)]
	}
	
	def dispatch void format(Message message, extension IFormattableDocument document) {
		message.regionFor.keyword("(").surround[noSpace]
		message.regionFor.keyword(")").prepend[noSpace].append[newLine]
		for(Parameter p : message.parameters) {
			if (message.parameters.indexOf(p) !== 0)
				p.prepend[space = " "]
			p.append[noSpace]	
		}
		//message.append[setNewLines(1,2,Integer.MAX_VALUE)]
	}
	
	def dispatch void format(Port port, extension IFormattableDocument document) {
		formatPort(port, document)
	}
	
	def dispatch void format(RequiredPort requiredPort, extension IFormattableDocument document) {
		formatPort(requiredPort, document)
	}
	
	def dispatch void format(ProvidedPort providedPort, extension IFormattableDocument document) {
		formatPort(providedPort, document)
	}

	def dispatch void format(InternalPort internalPort, extension IFormattableDocument document) {
		formatPort(internalPort, document)
	}
	
	def dispatch void format(Function function, extension IFormattableDocument document) {
		function.regionFor.keyword("(").append[noSpace].prepend[noSpace]
		function.regionFor.keyword(")").prepend[noSpace]
		for(Parameter p : function.parameters) {
			if (function.parameters.indexOf(p) !== 0)
				p.prepend[space = " "]
			p.append[noSpace]	
		}
		if (function.body !== null)
			function.body.format			
		function.append[setNewLines(2,2,Integer.MAX_VALUE)]
	}
	
	def dispatch void format(State state, extension IFormattableDocument document) {
		formatState(state, document)		
	}
	
	def dispatch void format(CompositeState state, extension IFormattableDocument document) {
		formatState(state, document)
		for (State sub : state.substate) {
			sub.format;
		}
		for(Region r : state.region) {
			formatStateContainer(r, document)
		}	
		for(Session s : state.session) {
			formatStateContainer(s, document)
		}	
	}
	
	def dispatch void format(Variable variable, extension IFormattableDocument document) {
		//variable.interior[indent]
		variable.append[newLine]		
	}
	
	def dispatch void format(Action action, extension IFormattableDocument document) {
		/*for(Expression e : ThingMLHelpers.getAllExpressions(action)) {
			e.format
		}*/
		action.interior[indent]
		action.append[newLine]		
	}
	
	def dispatch void format(SendAction action, extension IFormattableDocument document) {
		action.regionFor.keyword("!").append[noSpace].prepend[noSpace]
		action.regionFor.keyword("(").append[noSpace].prepend[noSpace]
		action.regionFor.keyword(")").append[noSpace].prepend[noSpace]
		for(Expression p : action.parameters) {
			p.prepend[space = " "]
			p.append[noSpace]	
		}
		action.append[newLine]		
	}	
	
	def dispatch void format(FunctionCallStatement action, extension IFormattableDocument document) {
		action.regionFor.keyword("(").append[noSpace].prepend[noSpace]
		action.regionFor.keyword(")").append[noSpace].prepend[noSpace]
		for(Expression p : action.parameters) {
			p.prepend[space = " "]
			p.append[noSpace]	
		}	
		action.append[newLine]	
	}	
	
	def dispatch void format(FunctionCallExpression exp, extension IFormattableDocument document) {
		exp.regionFor.keyword("(").append[noSpace].prepend[noSpace]
		exp.regionFor.keyword(")").append[noSpace].prepend[noSpace]
		for(Expression p : exp.parameters) {
			p.prepend[space = " "]
			p.append[noSpace]
		}		
	}	
	
	def dispatch void format(ActionBlock action, extension IFormattableDocument document) {		
		action.interior[indent]
		action.regionFor.keyword("do").append[newLine]
		action.regionFor.keyword("end").prepend[newLine]
		for(Action a : action.actions) {
			a.format
		}
		action.append[newLine]
	}
	
	def dispatch void format(ConditionalAction action, extension IFormattableDocument document) {
		action.action.format
		action.regionFor.keyword("(").append[noSpace]
		action.regionFor.keyword(")").prepend[noSpace]
		if (action.elseAction !== null) {
			action.append[newLine]
			action.elseAction.format	
		}
		action.append[newLine]		
	}
	
	def dispatch void format(VariableAssignment action, extension IFormattableDocument document) {
		action.regionFor.keyword("[").surround[noSpace]
		action.regionFor.keyword("]").prepend[noSpace]
		action.append[newLine]
	}	
	
	def dispatch void format(PropertyAssign assign, extension IFormattableDocument document) {
		assign.regionFor.keyword("[").surround[noSpace]
		assign.regionFor.keyword("]").prepend[noSpace]
		assign.regionFor.keyword(".").surround[noSpace]
		assign.append[newLine]
	}
	
	def dispatch void format(ConfigPropertyAssign assign, extension IFormattableDocument document) {
		assign.regionFor.keyword("[").surround[noSpace]
		assign.regionFor.keyword("]").prepend[noSpace]
		assign.regionFor.keyword(".").surround[noSpace]
		assign.append[newLine]
	}
	
	def dispatch void format(LoopAction action, extension IFormattableDocument document) {
		action.regionFor.keyword("(").append[noSpace]
		action.regionFor.keyword(")").prepend[noSpace]
		action.action.format	
		action.append[newLine]	
	}
	
	def dispatch void format(PropertyReference exp, extension IFormattableDocument document) {
		exp.regionFor.keyword(".").surround[noSpace]
	}
	
	def dispatch void format(EventReference exp, extension IFormattableDocument document) {
		exp.regionFor.keyword(".").surround[noSpace]
	}
	
	def dispatch void format(ExpressionGroup exp, extension IFormattableDocument document) {
		exp.regionFor.keyword("(").append[noSpace]
		exp.regionFor.keyword(")").prepend[noSpace]
	}

	def dispatch void format(ArrayIndex exp, extension IFormattableDocument document) {
		exp.regionFor.keyword("[").append[noSpace]
		exp.regionFor.keyword("]").prepend[noSpace]
	}
			
	def dispatch void format(UnaryMinus exp, extension IFormattableDocument document) {
		exp.regionFor.keyword("-").append[noSpace]
	}				
	
	// TODO: implement for , Enumeration, EnumerationLiteral, Thing, PropertyAssign, Protocol, Function, Property, Message, Parameter, , , , Stream, JoinSources, MergeSources, SimpleSource, Filter, LengthWindow, TimeWindow, StateMachine, FinalState, CompositeState, Session, ParallelRegion, State, Transition, InternalTransition, ActionBlock, ExternStatement, LocalVariable, SendAction, VariableAssignment, LoopAction, ConditionalAction, ReturnAction, PrintAction, ErrorAction, StartSession, FunctionCallStatement, ExternExpression, Configuration, Instance, ConfigPropertyAssign, Connector, ExternalConnector
	
	def dispatch void format(Handler h, extension IFormattableDocument document) {
		if(h.event !== null) {
			h.regionFor.keyword("event").prepend[newLine]
			h.event.regionFor.keyword("?").surround[noSpace]
			h.event.append[newLine]
		}
		if (h.guard !== null) {
			h.guard.append[newLine]
		}
		if (h.action !== null) {
			h.action.format
		}
		h.append[newLine].append[newLine]		
	}
	
	/* --- Helpers --- */
	
	
	def void formatStateContainer(StateContainer container, extension IFormattableDocument document) {
		for(State sub : container.substate) {
			sub.format
		}
		container.interior[indent]
		container.regionFor.keyword("{").append[newLine]
		container.regionFor.keyword("}").surround[newLine].append[newLine]
	}
	
	def void formatState(State state, extension IFormattableDocument document) {
		state.surround[newLine]
		state.interior[indent]
		for(Property p : state.properties) {
			p.format
		}
		state.regionFor.keyword("{").append[newLine]
		state.regionFor.keyword("}").surround[newLine]
		if (state.entry !== null)
			state.entry.format
		if (state.exit !== null)
			state.exit.format	
		for(Transition t: state.outgoing) {
			t.format
		}
		for(InternalTransition t: state.internal) {
			t.format
		}
	}
	
	def void formatType(Type type, extension IFormattableDocument document) {
		type.interior[indent]
		for (PlatformAnnotation annotations : type.getAnnotations()) {
			annotations.format;
			if (type.getAnnotations.size > 1) {
				annotations.prepend[newLine]
			}
		}
		type.append[newLine]
	}
	
	def void formatPort(Port port, extension IFormattableDocument document) {
		//FIXME: we should have: sends a, b, c and not sends a sends b sends c
		port.regionFor.keyword("{").append[newLine]
		port.regionFor.keyword("}").surround[newLine]
		port.interior[indent]

		for(Message m : port.receives) {
			m.append[newLine]
		}
					
		for(Message m : port.receives) {
			m.append[newLine]
		}
		port.append[newLine]
	}
}
