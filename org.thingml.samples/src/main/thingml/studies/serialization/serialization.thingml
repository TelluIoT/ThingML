datatype Integer
@scala_type "Int";

datatype String
@scala_type "String";

datatype Byte
@scala_type "Byte";

//test messages
thing fragment testMsgs {
    message m1();
    message m2(i : Integer);
    message m3(s : String);
    message m4(i : Integer, s : String);
}

//test thing
thing TestThing includes testMsgs
@mock "true"
{
    required port out {
       sends m1, m2, m3, m4
    }
    
    provided port in {
       receives m1, m2, m3, m4
    }        
}

/*
*  For all serializable datatype called D (D is the name of the ThingML datatype, not the underlying platform-specific datatype), define:
*  - lengthD() : Integer, which returns the size in bytes of the serialized type
*  - serializeD(d : D, bytes : Byte[MAX_PACKET_SIZE], startPosition : Integer), which puts the serialized datatype in the buffer, starting at bytes[startPosition]
*  - deserializeD(bytes : Byte[MAX_PACKET_SIZE], startPosition : Integer) : D, which gets the datatype from its serialized form, starting from bytes[startPosition]
*  The idea is inspired by the ByteBuffer provided by Java (http://download.oracle.com/javase/1.4.2/docs/api/java/nio/ByteBuffer.html), 
*  but this implementation aims at being as independent as possible to any specific platform, so that ThingML can seamlessly compile to different plaforms (Scala/Java, C, etc)
* 
*  ThingML comes along with serialize/deserialise functions for all the datatypes defined in the ThingML framework.
*  User defined datatypes that needs to be serialized should come along these functions.
*/
thing fragment DataTypeSerializerScala  includes PacketManager
{
    function lengthInteger() : Integer
    do
        return 1
    end
    
    function serializeInteger(d : Integer, bytes : Byte[MAX_PACKET_SIZE], startPosition : Integer)
    do
        bytes[startPosition] = '' & d & '.toByte'
    end
    
    function deserializeInteger(bytes : Byte[MAX_PACKET_SIZE], startPosition : Integer) : Integer
    do
        return bytes[startPosition]'.toInt'
    end    
    

    function lengthString() : Integer
    do
        return 8
    end
            
    function serializeString(d : String, bytes : Byte[MAX_PACKET_SIZE], startPosition : Integer) 
    do
        readonly var stop : Integer = startPosition+lengthString()
        var i : Integer = startPosition
        while(i < stop and i < MAX_PACKET_SIZE) do
            if (i-startPosition < '' & d & '.size') do
                bytes[i] = '' & d & '(' & i-startPosition & ').toByte'
                print(i + "=" + '' & d & '(' & i-startPosition & ').toByte')
            end
            i = i + 1
        end
    end
    
    function deserializeString(bytes : Byte[MAX_PACKET_SIZE], startPosition : Integer) : String 
    do
        var result : String = ""
        readonly var stop : Integer = startPosition+lengthString()
        var i : Integer = startPosition
        while(i < stop and i < MAX_PACKET_SIZE) do
            result = result + '' & bytes[i] & '.toChar'
            i = i + 1
        end
        print("deserialize = " + result)
        return result
    end
}

/**
 * This PacketManager manages fixed size packet (16 bytes by default)
 */
thing fragment PacketManager {
     readonly property MAX_PACKET_SIZE : Integer = 16   
     
     readonly property START_BYTE : Byte = '0x12'
	 readonly property STOP_BYTE : Byte = '0x13'
	 readonly property ESCAPE_BYTE : Byte = '0x7D'
     readonly property PADDING_BYTE : Byte = '0x00'
     
     readonly property CODE_POSITION : Integer = 4
     
     function setHeader(buffer : Byte[MAX_PACKET_SIZE], code : Byte) : Integer 
     do
	 	buffer[0] = START_BYTE
	 	buffer[1] = 1 // source addr (not used)
	 	buffer[2] = 0 // target addr (not used)
	 	buffer[3] = 0 // frame num (not used)
        buffer[4] = code
        finalize(buffer, 5)//pads and puts the STOP_BYTE. Note that too long messages will erase the stop byte, meaning that the message will be discarded at some point in the communication chain.
        return 5//position of the next byte to be written
	 end

    function finalize(buffer : Byte[MAX_PACKET_SIZE], startPosition : Integer)
    do
        readonly var endPosition : Integer = MAX_PACKET_SIZE - 1
        pad(buffer, startPosition, endPosition)
        buffer[endPosition] = STOP_BYTE
    end

    function pad(buffer : Byte[MAX_PACKET_SIZE], startPosition : Integer, stopPosition : Integer) 
    do
        var i : Integer = startPosition
        while (i < stopPosition and i < MAX_PACKET_SIZE -1) 
        do
            buffer[i] = PADDING_BYTE
            i = i +1
        end
    end
}

/**
 * Just a stupid Network component, for test purpose.
 * Retransmit everything it receives.
**/
thing Network includes PacketManager 
{
    message packet(p : Byte[MAX_PACKET_SIZE]);
    
    provided port in_net {
        receives packet    
    }    

    required port out_net {
        sends packet    
    }
    
    statechart NetworkBehavior init default {
        state default {
            internal event p : in_net?packet 
            action out_net!packet(p.p)    
        }    
    }
}

/*
*  This is what we should generate to handler the serialization 
* of all the remote messages send by an application
*/
thing MessageSerializer includes DataTypeSerializerScala, Network, testMsgs{
    
    provided port in_serial {
       receives m1, m2, m3, m4
    }
    
    required port network {
        sends packet    
    }
    
    statechart SerializerBehavior init Serialize {
        state Serialize{
             internal event m : in_serial?m1 action 
             do
                 var buffer : Byte[MAX_PACKET_SIZE]
                 
                 var position : Integer = setHeader(buffer, 1)
                 
                 //finalize(buffer, position)
                 network!packet(buffer)
             end
             
             internal event m : in_serial?m2 action 
             do
                 var buffer : Byte[MAX_PACKET_SIZE]
                 
                 var position : Integer = setHeader(buffer, 2)
                 
                 serializeInteger(m.i, buffer, position)
                 position = position + lengthInteger()
                 
                 //finalize(buffer, position)
                 network!packet(buffer)
             end
             
             internal event m : in_serial?m3 action 
             do
                 var buffer : Byte[MAX_PACKET_SIZE]
                 
                 var position : Integer = setHeader(buffer, 3)
                 
                 serializeString(m.s, buffer, position)
                 position = position + lengthString()
                 
                 //finalize(buffer, position)
                 network!packet(buffer)
             end
             
             internal event m : in_serial?m4 action 
             do
                 var buffer : Byte[MAX_PACKET_SIZE]
                 
                 var position : Integer = setHeader(buffer, 4)
                 
                 serializeInteger(m.i, buffer, position)
                 position = position + lengthInteger()
                 
                 serializeString(m.s, buffer, position)
                 position = position + lengthString()
                 
                 //finalize(buffer, position)
                 network!packet(buffer)
             end
        }
    }
}

/*
*  This is what we should generate to handler the serialization 
* of all the remote messages received by an application
*/
thing MessageDeserializer includes DataTypeSerializerScala, Network, testMsgs {
    required port out_serial {
       sends m1, m2, m3, m4
    }
    
    provided port network {
        receives packet    
    }
    
    function deserializeM1(buffer : Byte[MAX_PACKET_SIZE]) 
    do
        out_serial!m1()
    end
    
    function deserializeM2(buffer : Byte[MAX_PACKET_SIZE]) 
    do
        var position : Integer = CODE_POSITION + 1
        readonly var i : Integer = deserializeInteger(buffer, position)
        out_serial!m2(i)
    end
    
    function deserializeM3(buffer : Byte[MAX_PACKET_SIZE]) 
    do
        var position : Integer = CODE_POSITION + 1
        readonly var s : String = deserializeString(buffer, position)
        out_serial!m3(s)
    end
    
    function deserializeM4(buffer : Byte[MAX_PACKET_SIZE]) 
    do
        var position : Integer = CODE_POSITION + 1
        readonly var i : Integer = deserializeInteger(buffer, position)
        position = position + lengthInteger()
        readonly var s : String = deserializeString(buffer, position)
        out_serial!m4(i, s)
    end
            
     statechart DeserializerBehavior init Deserialize {
        state Deserialize {
         internal event packet : network?packet action 
             do
                 readonly var buffer : Byte[MAX_PACKET_SIZE] = packet.p
                 readonly var code : Integer = buffer[CODE_POSITION]
                 if (code == 1) do//we need else in ThingML so that the code generated can be more performant
                    deserializeM1(buffer)
                 end
                 if (code == 2) do
                    deserializeM2(buffer)
                 end
                 if (code == 3) do
                    deserializeM3(buffer)
                 end
                 if (code == 4) do
                    deserializeM4(buffer)
                 end
             end    
            
        }    
     }
}

/**
 * @remote annotations allows defining which ports are remote
 * syntax: instanceName::TypeName::PortName::messageName
 * note: wildcards can be used for any of these elements.
 */
configuration test 
@remote "testRemote::TestThing::.*::.*"
{
    //Messages are sent and received without serialization
    instance test : TestThing
    connector test.out => test.in
    
    //Messages are serialized, sent to (simulated) network, received, deserialized and sent to the former thing
    //hopefully, this has the same behavior than the configuration above...
    instance testRemote : TestThing
    instance net : Network
    instance serializer : MessageSerializer
    instance deserializer : MessageDeserializer
    
    connector testRemote.out => serializer.in_serial
    connector serializer.network => net.in_net
    connector net.out_net => deserializer.network
    connector deserializer.out_serial => testRemote.in
    
}