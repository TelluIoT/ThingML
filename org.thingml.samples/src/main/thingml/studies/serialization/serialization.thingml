import "../../core/_scala/serializer.thingml"
import "../../core/serializer.thingml"
import "../../core/comm.thingml"
import "../../core/timer.thingml"
import "../../core/_scala/timer.thingml"

//test messages
thing fragment testMsgs {
    message m4(i : Integer, s : String)@code "12";
    message m2(i : Integer);
    message m1()@code "27";
    message m3(s : String);
}

//test thing
thing TestThing includes testMsgs
@mock "true"
{
    required port out {
       sends m1, m2, m3, m4
    }
    
    provided port in {
       receives m1, m2, m3, m4
    }        
}

/*
*  Generated by ThingML
*/
thing MessageSerializer includes SerializerScala, OutputByteStreamMsgs, testMsgs, TimerClient{
    
    provided port in_serial {
       receives m1, m2, m3, m4
    }
    
    statechart SerializerBehavior init Serialize {
        state Serialize{
             transition -> Communication event m : in_serial?m1 action 
             do
                 setHeader(1,0)  
             end
             
             transition -> Communication event m : in_serial?m2 action 
             do  
                 setHeader(2,1)
                 serializeInteger(m.i)
             end
             
             transition -> Communication event m : in_serial?m3 action 
             do
                 setHeader(3,8)
                 serializeString(m.s)

             end
             
             transition -> Communication event m : in_serial?m4 action 
             do
                 setHeader(4,1+8)
                 serializeInteger(m.i)
                 serializeString(m.s)
             end
        }
        composite state Communication init send {
            on entry do
              index = 0
              network!write_byte(START_BYTE)
              timer!timer_start(DELAY)
            end
            
            on exit do
              network!write_byte(STOP_BYTE)
            end
            
            transition -> Serialize event m : timer?timer_timeout 
            guard index == DATA_POSITION + buffer[LENGTH_POSITION] 
            
            state send {
              internal event t : timer?timer_timeout
              guard index < DATA_POSITION + buffer[LENGTH_POSITION]
              action do
                network!write_byte(readByte())
                timer!timer_start(DELAY)
              end
            }            
        }
    }
}

/*
*  Generated by ThingML
*/
thing MessageDeserializer includes DeserializerScala, InputByteStreamMsgs, testMsgs {
    required port out_serial {
       sends m1, m2, m3, m4
    }
        
    function forward() do
        index = DATA_POSITION
        readonly var code : Byte = buffer[CODE_POSITION]
        if (code == 1) do//we need else in ThingML so that the code generated can be more performant
            deserializeM1()
        end
        if (code == 2) do
            deserializeM2()
        end
        if (code == 3) do
            deserializeM3()
        end
        if (code == 4) do
            deserializeM4()
        end
    end
        
    function deserializeM1() 
    do
        out_serial!m1()
    end
    
    function deserializeM2() 
    do
        readonly var i : Integer = deserializeInteger()
        out_serial!m2(i)
    end
    
    function deserializeM3() 
    do
        readonly var s : String = deserializeString()
        out_serial!m3(s)
    end
    
    function deserializeM4() 
    do
        readonly var i : Integer = deserializeInteger()
        readonly var s : String = deserializeString()
        out_serial!m4(i, s)
    end
                      
    statechart receive init Idle {
        state Idle {
		 	on entry index = 0	
		 	transition -> ReceiveMessage event m : network?receive_byte
		 	guard m.b == START_BYTE
		} 
		state ReceiveMessage {		
		 	transition -> Escape event m : network?receive_byte
		 	guard m.b == ESCAPE_BYTE
		 	
		 	internal event m : network?receive_byte
		 	guard not (m.b == ESCAPE_BYTE or m.b == STOP_BYTE)
		 	action storeByte(m.b)
		 	
		 	transition -> Idle event m : network?receive_byte
		 	guard m.b == STOP_BYTE
		 	action forward()
		 	
		 	internal event m : network?receive_byte
		 	guard m.b == START_BYTE // Should not happen with a reliable channel
		 	action index = 0 // Reset if it happens (some bytes have been lost at some point)
		}
		state Escape {
		 	transition receive -> ReceiveMessage
		 	event m : network?receive_byte
		 	action storeByte(m.b)
		}
    }
}

/**
 * @remote annotations allows defining which ports are remote
 * syntax: instanceName::TypeName::PortName::messageName
 * note: wildcards can be used for any of these elements.
 */
configuration test 
@remote "testRemote::TestThing::.*::.*"
{
    //Messages are sent and received without serialization
    instance test : TestThing
    connector test.out => test.in
    
    //Messages are serialized, sent to (simulated) network, received, deserialized and sent to the former thing
    //hopefully, this has the same behavior than the configuration above...
    instance testRemote : TestThing
    instance network : Network
    instance serializer : MessageSerializer
    instance deserializer : MessageDeserializer
    instance timer : TimerScala
    
    connector testRemote.out => serializer.in_serial
    connector serializer.network => network.IOStream
    connector serializer.timer => timer.timer
    connector deserializer.network => network.IOStream
    connector deserializer.out_serial => testRemote.in
    
}