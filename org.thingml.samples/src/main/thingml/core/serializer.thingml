import "../datatypes.thingml"
import "./comm.thingml"

//Defines constants and methods to manage variable size packets (with maximum size defined by MAX_PACKET_SIZE)
/*
*  For all serializable datatype called D (D is the name of the ThingML datatype, not the underlying platform-specific datatype), define:
*  - lengthD() : Integer, which returns the size in bytes of the serialized type. This should be defined here to ensure the consistencies of all serializer. However, datatypes whose size is determined dynamically (eg, VarString) should define this method in a PSm thing.
*  - serializeD(d : D, bytes : Byte[MAX_PACKET_SIZE], startPosition : Integer), which puts the serialized datatype in the buffer, starting at bytes[startPosition]. This should be defined in a PSM thing that include this thing.
*  - deserializeD(bytes : Byte[MAX_PACKET_SIZE], startPosition : Integer) : D, which gets the datatype from its serialized form, starting from bytes[startPosition]. This should be defined in a PSM thing that include this thing.
*  The idea is inspired by the ByteBuffer provided by Java (http://download.oracle.com/javase/1.4.2/docs/api/java/nio/ByteBuffer.html), 
*  but this implementation aims at being as independent as possible to any specific platform, so that ThingML can seamlessly compile to different plaforms (Scala/Java, C, etc)
* 
*  ThingML comes along with serialize/deserialise functions for all the datatypes defined in the ThingML framework.
*  User defined datatypes that needs to be serialized should come along these functions.
*/
thing fragment PacketManager {
        //Define the length (in bytes) of all the datatypes
        //TODO: Do it for all the other datatypes provided by ThingML
    readonly property lengthInteger : Byte = 1    
    readonly property lengthString : Byte = 8
    
    
    readonly property MAX_PACKET_SIZE : Integer = 18   
     
    readonly property START_BYTE : Byte = '0x12'
	readonly property STOP_BYTE : Byte = '0x13'
	readonly property ESCAPE_BYTE : Byte = '0x7D'
     
    //readonly property DELAY : UInt8 = 1
     
    property CODE_POSITION : Integer = 4
    property LENGTH_POSITION : Integer = 5
    property DATA_POSITION : Integer = 6
     
    property buffer : Byte[18]
    set buffer[0] = '0x12'
    set buffer[1] = '0x13'
    set buffer[2] = '0x13'
    set buffer[3] = '0x13'
    set buffer[4] = '0x13'
    set buffer[5] = '0x13'
    set buffer[6] = '0x13'
    set buffer[7] = '0x13'
    set buffer[8] = '0x13'
    set buffer[9] = '0x13'
    set buffer[10] = '0x13'
    set buffer[11] = '0x13'
    set buffer[12] = '0x13'
    set buffer[13] = '0x13'
    set buffer[14] = '0x13'
    set buffer[15] = '0x13'
    set buffer[16] = '0x13'
    set buffer[17] = '0x13'
	property index : Integer = 5
     
     function setHeader(code : Byte, length : Byte) 
     do
        index = 0
        storeByte(START_BYTE)
	 	storeByte(1) // source addr (not used)
	 	storeByte(0) // target addr (not used)
	 	storeByte(0) // frame num (not used)
        CODE_POSITION = index
        storeByte(code)
        LENGTH_POSITION = index
        storeByte(length)
        DATA_POSITION = index
        //We pad the rest with stop byte
        while(index < MAX_PACKET_SIZE) do
            //print("padding " + index)
            storeByte(STOP_BYTE)
            //i = i +1
        end
        index = DATA_POSITION
	 end

    function storeByte(b : Byte) do
        //print("store byte " + b + " at index " + index)
        if (index == MAX_PACKET_SIZE) do
            error("BUFFER OVERFLOW: " + b + " has been ignored. Current index = " + index)
        end
        if (index < MAX_PACKET_SIZE) do
	 	  buffer[index] = b
		  index = index + 1
        end
	end

    function readByte() : Byte do
        var b : Byte
        if (index < MAX_PACKET_SIZE) do
	 	  b = buffer[index]
          index = index + 1
        end
        if (index == MAX_PACKET_SIZE) do
          error("BUFFER OVERFLOW: trying to read out of buffer boundaries")
          b = STOP_BYTE
        end
        return b
	end
}

thing fragment Serializer includes PacketManager, OutputByteStreamMsgs {
    required port network {
        sends write_byte    
    }
    //TODO: this has to be revised
    function send() do
        print("send start byte = " + START_BYTE)
        network!write_byte(START_BYTE)
        readonly var stop : Integer = DATA_POSITION + buffer[LENGTH_POSITION] - 1
        var i : Integer = 0
        while(i < stop) do
            var b : Byte = buffer[i]
            if (b == START_BYTE or b == STOP_BYTE or b == ESCAPE_BYTE) do
                print("send escape byte = " + ESCAPE_BYTE)
                network!write_byte(ESCAPE_BYTE)
            end
            print("send data byte(" + i + ") = " + b)
            network!write_byte(b)
            i = i + 1
        end
        print("send stop byte = " + STOP_BYTE)
        network!write_byte(STOP_BYTE)
        index = 0
    end
}

thing fragment Deserializer includes PacketManager, InputByteStreamMsgs{
    required port network {
        receives receive_byte    
    }
    
    //function receive() do end//should be refined in a PSM thing
}

thing fragment ArraySerializer includes PacketManager, OutputByteArrayMsgs {
    required port network {
        sends write_bytes    
    }
    
    function send() do
        network!write_bytes(buffer)
    end
}

thing fragment ArrayDeserializer includes PacketManager, InputByteArrayMsgs{
    required port network {
        receives receive_bytes    
    }
    
    function forward()@abstract "true" do end//should be refined in a PSM thing
    
    function receive(bytes : Byte[18]) do
        index = 0
        //print("receive " + bytes)
        var i : Integer = 0
        var current : Byte = bytes[i]
        //print("byte " + i + " = " + current)
        if (current == START_BYTE) do
            storeByte(current)
            //print("Start OK")
            i = i + 1
            while(not (current == STOP_BYTE) and i < 18) do
                current = bytes[i]
                if (current == ESCAPE_BYTE and i < 17) do
                    i = i + 1
                    current = buffer[i]
                end
                //print("byte " + i + " = " + current)
                storeByte(current)
                i = i + 1
            end
            if (current == STOP_BYTE) do
                storeByte(current)
                forward()
            end
            if (not(current == STOP_BYTE)) do//ie index>=18
                error("It seems the packet was too long... (No stop byte was found before index 18)")
            end
        end
    end
}