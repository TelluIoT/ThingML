//Required installation to run this example:
//1) Clone https://github.com/SINTEF-9012/TinyOpenZWaveApi
//2) Navigate to open-zwave/install
//3) Run: make && make install
//4) Navigate to tiny-open-zwave-api/
//5) Run: make && make install
//6) install the udev library, make sure that pthread is also installed

import "../../thingml.thingml"
import "clock.thingml"

thing fragment NetworkMsg {
	message init_network();
	message initialized();
    message controller_set();
    message set_controller();
}

thing fragment NetworkInitializer includes NetworkMsg {
	
    provided port init_port {
    	sends initialized, controller_set
    	receives init_network, set_controller
    }
    
    statechart bahavior init Start {
    	
    	state Start{
    		on entry do
    			init_zwave()
    		end
            transition->Init
            event init_port?set_controller
    	}
        state Init{
            on entry do
                set_cotroller()
                init_port!controller_set()
            end
        }    
    }
}

thing ZWaveNetwork includes NetworkInitializer
@c_header "
#include \"tinyozw/Api.h\"

#include \"tinyozw/devices/BinarySwitch.h\"
#include \"tinyozw/libs/DomoZWave.h\"
#include \"tinyozw/libs/Utility.h\"

using namespace TinyOpenZWaveApi;
"
{
	property pport : String = "/dev/ttyUSB0"
	property config : String = "/usr/share/openzwave/config/"
	property zwdir : String = ""
	property domo_log : String = "./DomoZWave_Log"
	property enableLog : Boolean = true
	property enableZWLog : Boolean = false
	property polltime : Integer = 0

    
	 function network_is_ready_callback()
        @c_prototype "void network_is_ready_callback(void *_instance, ...)"
        @c_instance_var_name "(ZWaveNetwork_Instance *) _instance"
        do
            init_port!initialized()
        end

    function set_cotroller() do
        'OpenZWaveFacade::Get()->setCurrentController('& pport &');'
    end

	function init_zwave() do
		print "ZWaveNetwork: initializing ... \n"
        'ThingMLCallback *callback = new ThingMLCallback(network_is_ready_callback, _instance);'
		'OpenZWaveFacade::Init('& config &','& zwdir &','& domo_log &','& enableLog &','& enableZWLog &','& polltime &', callback);
		OpenZWaveFacade::Get()->AddController('& pport &');'
	end
}

thing fragment PlugMsg {
	message turn_on();
	message turn_off();
	message turned_off();
	message turned_on();
	message no_change();
	message plug_init();
    message plug_ready();
}

thing fragment Plug includes PlugMsg {
	
	provided port switch {
		sends turned_off, turned_on, no_change
		receives turn_on, turn_off
	}
	
	provided port init_plug {
		sends plug_ready
		receives plug_init
	}
	
	statechart behavior init Start {
		
		state Start {
			transition -> Ready
			event e : init_plug?plug_init
		}
		
		state Ready {
			on entry do 
                init_plug()
                init_plug!plug_ready()
            end
            
            transition -> TurnedOn
            event switch?turn_on
            
            internal event switch?turn_off
		}
		
		state TurnedOn{
			on entry do
				turn_on()
			end
			
			transition -> TurnedOn
			event switch?turn_on
			
			transition -> TurnedOff
			event switch?turn_off
		}
		
		state TurnedOff {
			on entry do
				turn_off()
			end
			
			transition ->TurnedOff
			event switch?turn_off
			
			transition -> TurnedOn
			event switch?turn_on
		}
	}
}

datatype BinarySwitch
@c_type "BinarySwitch*";


thing FibaroPlug includes Plug
@c_header "
#include \"tinyozw/Api.h\"

#include \"tinyozw/devices/BinarySwitch.h\"
#include \"tinyozw/libs/DomoZWave.h\"
#include \"tinyozw/libs/Utility.h\"

using namespace TinyOpenZWaveApi;
"
 {

	property nodeId : Integer
	property cInstance : Integer
	property cIndex : Integer
    property bs : BinarySwitch
    
    function turned_on_callback()
    @c_prototype "void turned_on_callback(void *_instance, ...)"
    @c_instance_var_name "(FibaroPlug_Instance *) _instance"
    do
        switch!turned_on()
    end
    
    function turned_off_callback()
    @c_prototype "void turned_off_callback(void *_instance, ...)"
    @c_instance_var_name "(FibaroPlug_Instance *) _instance"
    do
        switch!turned_off()
    end
    
    function no_change_callback()
    @c_prototype "void no_change_callback(void *_instance, ...)"
    @c_instance_var_name "(FibaroPlug_Instance *) _instance"
    do
        switch!no_change()
    end
	
	function init_plug() do
        print "FibaroPlug: initializing ... \n"
        'ThingMLCallback* turned_on = new ThingMLCallback(turned_on_callback, _instance);'
        'ThingMLCallback* turned_off = new ThingMLCallback(turned_off_callback, _instance);'
        'ThingMLCallback* no_change = new ThingMLCallback(no_change_callback, _instance);'
        bs = 'new BinarySwitch(turned_on, turned_off, no_change);'
        bs = ''&bs&'->BinarySwitch::Init(OpenZWaveFacade::Get(), (uint8)' & nodeId & ',(uint8)' & cInstance & ', (uint8)'& cIndex &');'
	end
	

    function turn_on() do
         print "FibaroPlug: turning plug on ... \n"
        ''&bs&'->turnOn();'
    end

    function turn_off() do
        print "FibaroPlug: turning plug off ... \n"
        ''&bs&'->turnOff();'
    end
}

thing HomeCenter includes PlugMsg, NetworkMsg, ClockMsgs {
	
	required port switch {
		sends turn_on, turn_off
		receives turned_off, turned_on, no_change
	}
	
	required port init_plug {
		sends plug_init
		receives plug_ready
	}
	
	required port init_port {
		sends init_network, set_controller
		receives initialized, controller_set
	}

    required port signal {
        receives clock_tick
    }
	
	statechart behavior init Start {
		state Start {
			on entry do
				print "HomeCenter: starting ...\n"
			end
			
			transition -> InitController
			event e : init_port?initialized
		}
		
        state InitController {
            on entry do
                print "HomeCenter: setting controller...\n"
                init_port!set_controller()
            end
            
            transition-> NetworkReady
            event init_port?controller_set
        }

		state NetworkReady {
			on entry do
				print "HomeCenter: network is ready \n"
				init_plug!plug_init()
			end
			
			transition -> TurnOnPlug
			event e : init_plug?plug_ready action print "HomeCenter: plug is ready \n"     
		}

        state TurnOnPlug{
            on entry do
                print "HomeCenter: turn plug on \n" 
                switch!turn_on()
            end
            
            transition ->WaitForSignalToTurnOff
            event switch?turned_on
            
            //transition ->TurnOnPlug
            //event switch?turned_off
            
            internal event switch?no_change action switch!turn_on()
        }
        
        state WaitForSignalToTurnOff{
            
            transition ->TurnOffPlug
            event signal?clock_tick
        }
        
        state TurnOffPlug {
            on entry do
                print "HomeCenter: turn plug off \n" 
                switch!turn_off()
            end
            
            transition ->WaitForSignalToTurnOn
            event switch?turned_off
            
            //transition ->TurnOffPlug
            //event switch?turned_on
            
            internal event switch?no_change action switch!turn_off()
        }
        
        state WaitForSignalToTurnOn{
            
            transition ->TurnOnPlug
            event signal?clock_tick
        }
	}
}



configuration LinuxHomeCenterTest
  @output_folder "/home/tmp/"
  @debug "true"
  @debug_fifo "true"
  @debug_message_send ".*"
  @debug_message_receive ".*"
  @add_c_libraries "udev pthread openzwave tinyozw"
{
	instance p1 : FibaroPlug
	set p1.nodeId = 5
	set p1.cInstance = 1
	set p1.cIndex = 0
		
	instance n : ZWaveNetwork


    instance clock : ClockLinux
    set clock.period = 5000
	
	// Create and connect the test app
	instance app : HomeCenter
	connector app.switch => p1.switch
    //connector app.switch => p2.switch
	connector app.init_plug => p1.init_plug
    //connector app.init_plug => p2.init_plug
	connector app.init_port => n.init_port

    connector app.signal => clock.signal
}